
#include <s6e2cc.h>
#include "platform.h"
#include "i2s.h"

#ifndef TRUE
  #define TRUE 1 
#endif

#ifndef FALSE
  #define FALSE  0
#endif  

/* Name: i2s_init   
* Description: Initialization I2S bus clock and Pins.   
* I2S MCLK   P5D
* I2S DO		 P5E
* I2S DI		 P30
* I2S BCLK	 P31
* I2S WS		 PF5
* switch		 P3C  This pin controls the analog switch that is used to select between ADCLRC and DACLRC
* 
* Configuration: Slave, 16 bits data, Stereo
*/    

void i2s_init(char sampling_rate, char mode) {   

// enable I2S0 peripheral
	bFM4_CLK_GATING_CKEN2_I2SCK0 = 1u;   //The bus clock is supplied to the peripheral.

// Pin configuration
  FM4_GPIO->EPFR24 |= (1ul << 2ul);    // I2S0-MCLK pin to input
  bFM4_GPIO_PFR5_PD = 1u;

  FM4_GPIO->EPFR24 |= (1ul << 10ul);   // I2S0-DO pin to output
  bFM4_GPIO_PFR5_PE = 1u;
	
	FM4_GPIO->EPFR24 |= (1ul << 8ul);    // I2S0-DI pin to input   
  bFM4_GPIO_PFR5_PE = 1u;

  FM4_GPIO->EPFR24 |= (1ul << 4ul);    // I2S0-CK pin to input/output (input used)
  bFM4_GPIO_PFR3_P1 = 1u;

  FM4_GPIO->EPFR24 |= (1ul << 6ul);    // I2S0-WS pin to input/output (input used)
  bFM4_GPIO_PFR5_PF = 1u;
	bFM4_GPIO_DDR3_PC = 1u;              // Output
	
	
// Configure the I2S module 

  bFM4_I2SPRE_ICCR_ICEN =0u;					 // Disables I2S MCLK output. The clock will be generated by the CODEC.
 
  FM4_I2S0->OPRREG_f.START = 0u;       // Stops the I2S interface while configuring.  
  // Clock divider configuration
  FM4_I2S0->CNTREG_f.CKRT  = 0u;       // 0: Bypass: Use Wolfson clock
	//Overhead bits
  if (sampling_rate == hz8000) FM4_I2S0->CNTREG_f.OVHD  = 352;     
  if (sampling_rate == hz32000) FM4_I2S0->CNTREG_f.OVHD  = 64;     
  if (sampling_rate == hz48000) FM4_I2S0->CNTREG_f.OVHD  = 32;     
  if (sampling_rate == hz96000) FM4_I2S0->CNTREG_f.OVHD  = 0;     
	
  FM4_I2S0->CNTREG_f.MSKB  = FALSE ;   // No mask bit
  // Master - Slave configuration 
  FM4_I2S0->CNTREG_f.MSMD  = FALSE ;   // Slave mode
  // Number of Subframe constructions
  FM4_I2S0->CNTREG_f.SBFN  =  FALSE ;  // 1 Subframe ; 2 channels on the same subframe. 
	// Word construction of FIFO 
  FM4_I2S0->CNTREG_f.RHLL  = TRUE ;    // two 16 channels combined into a 32-bit FIFO word    
	//Base clock divider (in master mode)
	FM4_I2S0->CNTREG_f.ECKM = FALSE;
  // Bit extension
  FM4_I2S0->CNTREG_f.BEXT  = FALSE ;   // Bit extension not used
  // Output Mode of Frame Synchronous Signal
  FM4_I2S0->CNTREG_f.FRUN  = FALSE;    // Don't start free running
  // Shifting order
  FM4_I2S0->CNTREG_f.MLSB  = FALSE;    // Shift starts from MSB of word 
  // Sampling point of data reception
  FM4_I2S0->CNTREG_f.SMPL  = FALSE;    // Sampling is performed in the middle of the receive data.
  // Clock polarity
  FM4_I2S0->CNTREG_f.CPOL  = TRUE;     // Drives data at the falling edge of I2SCK and is sampled at the rising edge of I2SCK. 
  // Frame Sync Phase
  FM4_I2S0->CNTREG_f.FSPH  = FALSE;    // I2SWS is enabled at the same time as the frame data and first bit. 
  // Frame Sync Pulse Width
  FM4_I2S0->CNTREG_f.FSLN  = TRUE;     // Pulse width will be one channel length (1 channel).
  // Frame Sync Polarity
  FM4_I2S0->CNTREG_f.FSPL  = FALSE;    // I2SWS is "1", and the frame sync signal is enabled. This is "0" when idle.
	
	
  // Configuration for Sub Frame 0
  FM4_I2S0->MCR0REG_f.S0CHN  =  1u ;   //Number of channels -1 for subfram_0 (two channels)
  FM4_I2S0->MCR0REG_f.S0CHL  =  15u;   //Bit length -1 of the channels that make up subframe 0 (32bit)
  FM4_I2S0->MCR0REG_f.S0WDL  =  15u;   //Word length - 1.

  // Set active channels for Sub Frame 0   
  FM4_I2S0->MCR1REG  = 0x00000003u;    // Enable channel 0 and 1 in subframe 0

  // Transmit interrupt settings
  FM4_I2S0->INTCNT_f.TXUD0M = TRUE;
  FM4_I2S0->INTCNT_f.TXUD1M = TRUE;
  FM4_I2S0->INTCNT_f.TBERM  = TRUE;
  FM4_I2S0->INTCNT_f.TXOVM  = TRUE;
  if (mode == intr)FM4_I2S0->INTCNT_f.TXFDM  = TRUE;
	else if (mode == dma)FM4_I2S0->INTCNT_f.TXFDM  = FALSE; //A DMA request is made when the receive dat written to the transmit FIFO meets or exceeds the threshold value.
  if (mode == intr) FM4_I2S0->INTCNT_f.TXFIM  = FALSE;    //An interrupt is issued to the CPU when the transmit FIFO empty space meets or exceeds the threshold value
	else if (mode == dma)FM4_I2S0->INTCNT_f.TXFIM  = TRUE;
	FM4_I2S0->INTCNT_f.FERRM  = TRUE;

  // Recive interrupt settings
  FM4_I2S0->INTCNT_f.RBERM  = TRUE; 
  FM4_I2S0->INTCNT_f.RXUDM  = TRUE; 
  FM4_I2S0->INTCNT_f.RXOVM  = TRUE;
  if (mode == intr)FM4_I2S0->INTCNT_f.RXFDM  = TRUE;
	else if (mode == dma)FM4_I2S0->INTCNT_f.RXFDM  = FALSE; //A DMA request is made when the receive data written to the transmit FIFO meets or exceeds the threshold value.
  FM4_I2S0->INTCNT_f.EOPM   = TRUE;
  FM4_I2S0->INTCNT_f.RXFIM  = TRUE; 
	FM4_I2S0->INTCNT_f.RPTMR  = 0x0;  
	
}

void i2s_rx_enable(){  //Enable I2S Receive 
  FM4_I2S0->OPRREG_f.RXENB = TRUE; 
  FM4_I2S0->CNTREG_f.RXDIS = FALSE;  
}

void i2s_tx_enable(){ // Enable I2S Transmitter 
     
  FM4_I2S0->OPRREG_f.TXENB = TRUE; 
  FM4_I2S0->CNTREG_f.TXDIS = FALSE;
}

void i2s_rx_threshold(int d){
  FM4_I2S0->INTCNT_f.RFTH = 0x0F & (d-1);
}

void i2s_tx_threshold(int d){
	FM4_I2S0->INTCNT_f.TFTH = 0x0F & (d-1);
}

void i2s_rx_dma_enable(){
	bFM4_I2S0_DMAACT_RL1E0 = TRUE; //Enable I2S receive DMA request; Level-Sensitive mode
	bFM4_I2S0_DMAACT_RDMACT = TRUE;
	
}

void i2s_tx_dma_enable(){
  bFM4_I2S0_DMAACT_TL1E0 = TRUE;//Enable I2S transmit DMA request; Level-Sensitive mode
	bFM4_I2S0_DMAACT_TDMACT = TRUE;
}

void i2s_start(void){
    
  FM4_I2S0->OPRREG_f.START  = 1u ; //Start the I2S module
}

void i2s_stop(void){
    
  FM4_I2S0->OPRREG_f.START  = 0u ; //Stop the I2S module
}

uint32_t i2s_rx(void){
return 	FM4_I2S0->RXFDAT;  				 //Reads data from the receive FIFO register register  
}

void i2s_tx(uint32_t c){
	FM4_I2S0->TXFDAT = c;  
}

static void (*i2s_callback)(void) = 0;

void i2s_set_callback(void (*callback)(void)) {
	i2s_callback = callback;

  NVIC_ClearPendingIRQ(PRGCRC_I2S_IRQn);
  NVIC_EnableIRQ(PRGCRC_I2S_IRQn);
  NVIC_SetPriority(PRGCRC_I2S_IRQn, 2); 
}

 void PRGCRC_I2S_IRQHandler(void) {
	if (i2s_callback) {
		i2s_callback();
		NVIC_ClearPendingIRQ(PRGCRC_I2S_IRQn);
	}
}

// *******************************ARM University Program Copyright Â© ARM Ltd 2015*************************************   
